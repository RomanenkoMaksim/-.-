#!/usr/bin/env python
# coding: utf-8

# # КОММЕНТАРИЙ РЕВЬЮВЕРА
# Привет Максим!)
# 
# Меня зовут Сибирев Владислав, я осуществлял проверку проекта. Может перейдем сразу на <b>ты</b>? Если это неприемлемо, то обязательно дай знать)
# 
# Далее по ходу работы ты сможешь встретить мои комментарии, они будут отмечены разными цветами:
# 
# <div class="alert alert-block alert-success">
#  ✔️ Похвала и возможности развития
# </div>
# <div class="alert alert-block alert-warning">
# ⚠️ Некритичные замечания, но стоит обратить внимание
# </div>
# <div class="alert alert-block alert-danger">
# ❌ Грубая ошибка, необходимо исправить
# </div>
# 
# 
# Заранее прошу не удалять мои комментарии, это важно. Если у тебя возникнут вопросы, обозначь их, я с радостью тебе помогу!)
# 
# Как вариант, можешь обозначить их так:
# <div class="alert alert-block alert-info">
# <b>КОММЕНТАРИЙ СТУДЕНТА:</b>

# # Исследование надежности заемщиков
# 

# Во второй части проекта вы выполните шаги 3 и 4. Их вручную проверит ревьюер.
# Чтобы вам не пришлось писать код заново для шагов 1 и 2, мы добавили авторские решения в ячейки с кодом. 
# 
# 

# ## Откройте таблицу и изучите общую информацию о данных

# **Задание 1. Импортируйте библиотеку pandas. Считайте данные из csv-файла в датафрейм и сохраните в переменную `data`. Путь к файлу:**
# 
# `/datasets/data.csv`

# In[1]:


import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt 


# In[2]:


try:
    data = pd.read_csv('/datasets/data.csv')
except:
    data = pd.read_csv('https://code.s3.yandex.net/datasets/data.csv')


# In[3]:


pd.options.display.float_format = '{:,.5f}'.format


# <div class="alert alert-block alert-success">
# <b>Комментарий ревьюера:</b> 
# 
# ✔️ Молодец, что используешь конструкцию __try и except__<br>
# P.S. Для следующих проектов нужно импортировать библиотеки в отдельной ячейке) Это позволяет быстро сориентироваться, что нужно для запуска проекта, если кто-то будет запускать его в другом окружении.
#   </div>

# **Задание 2. Выведите первые 20 строчек датафрейма `data` на экран.**

# In[4]:


data.head(20)


# **Задание 3. Выведите основную информацию о датафрейме с помощью метода `info()`.**

# In[5]:


data.info()


# <div class="alert alert-block alert-success">
# <b>Комментарий ревьюера:</b> 
# 
# ✔️ Также в последствии можно использовать метод describe(), он показывает некоторые статистические данные, в общем тоже полезный метод https://www.javatpoint.com/pandas-dataframe-describe#:~:text=The%20describe()%20method%20is,sets%20of%20mixed%20data%20types.
#   </div>

# ## Предобработка данных

# ### Удаление пропусков

# **Задание 4. Выведите количество пропущенных значений для каждого столбца. Используйте комбинацию двух методов.**

# In[6]:


data.isna().sum()


# <div class="alert alert-block alert-success">
# <b>Комментарий ревьюера:</b>
# 
# ✔️ Изучить долю пропущенных пропусков можно еще с помощью `data.isna().mean()*100`
#   </div>

# **Задание 5. В двух столбцах есть пропущенные значения. Один из них — `days_employed`. Пропуски в этом столбце вы обработаете на следующем этапе. Другой столбец с пропущенными значениями — `total_income` — хранит данные о доходах. На сумму дохода сильнее всего влияет тип занятости, поэтому заполнить пропуски в этом столбце нужно медианным значением по каждому типу из столбца `income_type`. Например, у человека с типом занятости `сотрудник` пропуск в столбце `total_income` должен быть заполнен медианным доходом среди всех записей с тем же типом.**

# In[7]:


for t in data['income_type'].unique():
    data.loc[(data['income_type'] == t) & (data['total_income'].isna()), 'total_income'] =     data.loc[(data['income_type'] == t), 'total_income'].median()


# <div class="alert alert-block alert-success">
# <b>Комментарий ревьюера:</b>
# 
#  ✔️  Можно также использовать следующую конструкцию `data['total_income'] = data['total_income'].fillna(data.groupby(['income_type'])['total_income'].transform('median'))`
# Функция transform() в принципе полезная https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.transform.html
#   </div>

# ### Обработка аномальных значений

# **Задание 6. В данных могут встречаться артефакты (аномалии) — значения, которые не отражают действительность и появились по какой-то ошибке. таким артефактом будет отрицательное количество дней трудового стажа в столбце `days_employed`. Для реальных данных это нормально. Обработайте значения в этом столбце: замените все отрицательные значения положительными с помощью метода `abs()`.**

# In[8]:


data['days_employed'] = data['days_employed'].abs()


# <div class="alert alert-block alert-success">
# <b>Комментарий ревьюера:</b>
# 
#  ✔️  Все верно молодец, что используешь функцию abs()
#   </div>

# **Задание 7. Для каждого типа занятости выведите медианное значение трудового стажа `days_employed` в днях.**

# In[9]:


data.groupby('income_type')['days_employed'].agg('median')


# У двух типов (безработные и пенсионеры) получатся аномально большие значения. Исправить такие значения сложно, поэтому оставьте их как есть. Тем более этот столбец не понадобится вам для исследования.

# **Задание 8. Выведите перечень уникальных значений столбца `children`.**

# In[10]:


data['children'].unique()


# **Задание 9. В столбце `children` есть два аномальных значения. Удалите строки, в которых встречаются такие аномальные значения из датафрейма `data`.**

# In[11]:


data = data[(data['children'] != -1) & (data['children'] != 20)]


# <div class="alert alert-block alert-success">
# <b>Комментарий ревьюера:</b>
# 
#  ✔️  Все верно, можно еще использовать query(). который позволяет работать с нужными данными) https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.query.html
#   </div>

# **Задание 10. Ещё раз выведите перечень уникальных значений столбца `children`, чтобы убедиться, что артефакты удалены.**

# In[12]:


data['children'].unique()


# ### Удаление пропусков (продолжение)

# **Задание 11. Заполните пропуски в столбце `days_employed` медианными значениями по каждого типа занятости `income_type`.**

# In[13]:


for t in data['income_type'].unique():
    data.loc[(data['income_type'] == t) & (data['days_employed'].isna()), 'days_employed'] =     data.loc[(data['income_type'] == t), 'days_employed'].median()


# **Задание 12. Убедитесь, что все пропуски заполнены. Проверьте себя и ещё раз выведите количество пропущенных значений для каждого столбца с помощью двух методов.**

# In[14]:


data.isna().sum()


# ### Изменение типов данных

# **Задание 13. Замените вещественный тип данных в столбце `total_income` на целочисленный с помощью метода `astype()`.**

# In[15]:


data['total_income'] = data['total_income'].astype(int)


# ### Обработка дубликатов

# **Задание 14. Обработайте неявные дубликаты в столбце `education`. В этом столбце есть одни и те же значения, но записанные по-разному: с использованием заглавных и строчных букв. Приведите их к нижнему регистру. Проверьте остальные столбцы.**

# In[16]:


data['education'] = data['education'].str.lower()


# **Задание 15. Выведите на экран количество строк-дубликатов в данных. Если такие строки присутствуют, удалите их.**

# In[17]:


data.duplicated().sum()


# In[18]:


data = data.drop_duplicates()


# <div class="alert alert-block alert-success">
# <b>Комментарий ревьюера:</b>
# 
# ✔️  От дубликатов избавился, молодец)
#   </div>

# ### Категоризация данных

# **Задание 16. На основании диапазонов, указанных ниже, создайте в датафрейме `data` столбец `total_income_category` с категориями:**
# 
# - 0–30000 — `'E'`;
# - 30001–50000 — `'D'`;
# - 50001–200000 — `'C'`;
# - 200001–1000000 — `'B'`;
# - 1000001 и выше — `'A'`.
# 
# 
# **Например, кредитополучателю с доходом 25000 нужно назначить категорию `'E'`, а клиенту, получающему 235000, — `'B'`. Используйте собственную функцию с именем `categorize_income()` и метод `apply()`.**

# In[19]:


def categorize_income(income):
    try:
        if 0 <= income <= 30000:
            return 'E'
        elif 30001 <= income <= 50000:
            return 'D'
        elif 50001 <= income <= 200000:
            return 'C'
        elif 200001 <= income <= 1000000:
            return 'B'
        elif income >= 1000001:
            return 'A'
    except:
        pass


# In[20]:


data['total_income_category'] = data['total_income'].apply(categorize_income)
data['total_income_category'].value_counts()


# <div class="alert alert-block alert-success">
# <b>Комментарий ревьюера:</b>
# 
# ✔️  Функцию написал правильную, молодец, но применение функции лучше проверять с помощью `value_counts`, вдруг какое то условие не сработало)
# 
#   </div>

# **Задание 17. Выведите на экран перечень уникальных целей взятия кредита из столбца `purpose`.**

# In[21]:


data['purpose'].unique()


# **Задание 18. Создайте функцию, которая на основании данных из столбца `purpose` сформирует новый столбец `purpose_category`, в который войдут следующие категории:**
# 
# - `'операции с автомобилем'`,
# - `'операции с недвижимостью'`,
# - `'проведение свадьбы'`,
# - `'получение образования'`.
# 
# **Например, если в столбце `purpose` находится подстрока `'на покупку автомобиля'`, то в столбце `purpose_category` должна появиться строка `'операции с автомобилем'`.**
# 
# **Используйте собственную функцию с именем `categorize_purpose()` и метод `apply()`. Изучите данные в столбце `purpose` и определите, какие подстроки помогут вам правильно определить категорию.**

# In[22]:


def categorize_purpose(row):
    try:
        if 'автом' in row:
            return 'операции с автомобилем'
        elif 'жил' in row or 'недвиж' in row:
            return 'операции с недвижимостью'
        elif 'свад' in row:
            return 'проведение свадьбы'
        elif 'образов' in row:
            return 'получение образования'
    except:
        return 'нет категории'


# In[23]:


data['purpose_category'] = data['purpose'].apply(categorize_purpose)
data['purpose_category'].value_counts()


# <div class="alert alert-block alert-success">
# <b>Комментарий ревьюера:</b>
# 
# ✔️ Здесь порядок, но лучше проверять всегда работает ли функция))
#   </div>

# ### Шаг 3. Исследуйте данные и ответьте на вопросы

# #### 3.1 Есть ли зависимость между количеством детей и возвратом кредита в срок?

# In[24]:


data_pivot_children = data.pivot_table(index=['children'], values = 'debt', aggfunc=['sum', 'count', 'mean'])
data_pivot_children.columns = ['debt', 'all', 'mean']
data_pivot_children['mean'] = data_pivot_children['mean'].round(3) * 100
data_pivot_children['percent_from_all'] = ((data_pivot_children['all'] / data_pivot_children['all'].sum()) * 100).round(2)
data_pivot_children = data_pivot_children.sort_values(by= 'mean').reset_index()
data_pivot_children['children'] = data_pivot_children['children'].astype('str')
display(data_pivot_children)

#data_pivot_children_teori = data.pivot_table(index=['children', 'total_income_category'], values = 'debt', aggfunc=len)


# In[25]:


plt.title('Зависимость между количеством детей и возвратом кредита')
sns.barplot(x='mean', y='children', data=data_pivot_children)
plt.show()


# **При анализе данных с выборки по количеству детей первоначально можно сделать вывод, что самые добросовестные кредитозаниматели - это люди, у которых либо нет детей, либо их 3 или 4. Однако, при сравнении каждой категории с общим числом, можно проследить, что из 6 категорий 98,22% составляют семьи без детей, с одним или двумя. Для формулирования вывода, считаю целесообразным, отбросить категории, составляющие в общем объёме менее 2%. Соответственно: Есть достаточно ощутимое изменение между возвратом кредита в срок между заёмщиками без детей и с одним и более. При наличии в семье от одного ребёнка и больше процент того, что кредит не будет погашен в срок возрастает на 22%.** 

# <div class="alert alert-block alert-success">
# <b>Комментарий ревьюера:</b>
# 
# ✔️ Здесь все конечно круто сделал) 
#   </div>

# <div class="alert alert-block alert-warning">
# <b>КОММЕНТАРИЙ РЕВЬЮВЕРА:</b> 
#     
#     
# ⚠️ Что нужно будет оптимизировать: 
# 1) data_pivot_children = data.pivot_table(index=['children'], values = 'debt', aggfunc=[sum, len, mean]). Mean позволит вычислить долю как раз должников. Этот столбец смело умножай на 100.<br>
# 2) Можешь сразу же здесь сбросить индексы здесь и удалить первый уровень с помощью droplevel(1, axis=1)<br>
# 3) График отличный построил, но не забудь про название его, чтобы было понятно, что ты изучаешь с помощью графика.<br>
# 4) Сделай так `import seaborn as sns`, и нужно импортировать все библиотеки  в первой ячейке кода. <br>
# 
# </div>

# <div class="alert alert-block alert-info">
# <b> 1) data_pivot_children = data.pivot_table(index=['children'], values = 'debt', aggfunc=[sum, len, mean] код падает с ошибкой NameError и ругается на mean. 
#     2) + Сделал, но не смог понять зачем использовать  droplevel(1, axis=1) в данном примере, если reset_index() делает всё то же самое и его удобнее использовать после сортировки, что бы не сбились индексы.
#     3) +
#     4) +
#     </b>

# <div class="alert alert-block alert-warning">
# <b>КОММЕНТАРИЙ РЕВЬЮВЕРА_V2:</b> 
#     
#     
# ⚠️ Давай тогда здесь по порядку, чтобы было наглядней код пропишу c порядком действий) Да, в твоем случае и не нужен `droplevel(1, axis=1)`, так как ты потом переименовывал столбцы, такое решение тоже возможно)) 

# In[26]:


##Код ревьюера
##Не заработало так как здесь прописываются функции в кавычках, я когда скопировал не заметид, что у тебя нет кавычек, плюс надо вместо len использовать "count" 
data_pivot_children1 = data.pivot_table(index=['children'], values = 'debt', aggfunc=['sum', 'count', 'mean'])
display(data_pivot_children1)
##Здесь мы сбрасываем индекс
data_pivot_children1 = data_pivot_children1.reset_index()
display(data_pivot_children1)
##А здесь избавляемся от ненужного нам названия мультииндекса debt
data_pivot_children1 = data_pivot_children1.droplevel(1, axis=1)
display(data_pivot_children1)


# <div class="alert alert-block alert-warning">
# <b>КОММЕНТАРИЙ РЕВЬЮВЕРА_V2:</b> 
#     
#     
# ⚠️ Название графика не стоит прописывать с помощью print(), лучше print() использовать для вывода текста)) Ну и конечно импортируем мы по правилам хорошего тога библиотеку в первую ячейку кода)

# <div class="alert alert-block alert-info">
# <b> Мне не нравилась идея с print(), но я не хотел усложнять проект с matplotlib, так как не знаю как точно он работает, но пока искал как можно добавить название графику нашёл только его. Благодарю за объяснение.
#     </b>

# <div class="alert alert-block alert-success">
# <b>Комментарий ревьюера_V3:</b>
# 
# ✔️ Молодец, оптимизировал код)) По поводу графиков, по другому к сожалению не получится, в дальнейшем будете изучать  `matplotlib`, это библиотека,Ю которая позволяет строить графики chrome-extension://efaidnbmnnnibpcajpcglclefindmkaj/https://indico-hlit.jinr.ru/event/151/attachments/340/492/Project_school_Matplotlib_original.pdf)) 
#   </div>

# #### 3.2 Есть ли зависимость между семейным положением и возвратом кредита в срок?

# In[27]:


data_pivot_family = data.pivot_table(index=['family_status'], values = 'debt', aggfunc=['sum', 'count', 'mean'])
data_pivot_family.columns = ['debt', 'all', 'mean']
data_pivot_family['mean'] = data_pivot_family['mean'].round(3) * 100
data_pivot_family['percent_from_all'] = ((data_pivot_family['all'] / data_pivot_family['all'].sum()) * 100).round(2)
data_pivot_family = data_pivot_family.sort_values(by= 'mean').reset_index()
display(data_pivot_family)
#data_pivot_family_teori = data[data['family_status'] == 'гражданский брак'].pivot_table(index=['family_status', 'dob_years'], values = 'debt', aggfunc=len)


# In[28]:


plt.title('Зависимость между семейным положением и возвратом кредита')
sns.barplot(x='mean', y='family_status', data=data_pivot_family)
plt.show()


# **В данном вопросе можно сказать, что значения вдов/вдовцов аномально выбиваются, однако все 5 категорий можно сгруппировать в три: состояли ли в официальном браке, не состояли, гражданский брак. Анализируя эти три категории можно сказать, что люди, состоявшие в официальном браке более склонны к возвращению кредита в срок. Явно выражен скачёк невозврата для последних двух категорий, отображённых в диаграмме.** 

# #### 3.3 Есть ли зависимость между уровнем дохода и возвратом кредита в срок?

# In[29]:


data_pivot_income = data.pivot_table(index=['total_income_category'], values = 'debt', aggfunc=['sum', 'count', 'mean'])
data_pivot_income.columns = ['debt', 'all', 'mean']
data_pivot_income['mean'] = data_pivot_income['mean'].round(3) * 100
data_pivot_income['percent_from_all'] = ((data_pivot_income['all'] / data_pivot_income['all'].sum()) * 100).round(2)
data_pivot_income = data_pivot_income.sort_values(by= 'mean').reset_index()
display(data_pivot_income)


# In[30]:


plt.title('Зависимость между уровнем дохода и возвратом кредита')
sns.barplot(x='mean', y='total_income_category', data=data_pivot_income)
plt.show()


# **Для формулирования вывода к этому вопросу, я бы предложил отбросить категории, составляющие в сумме менее 2% в выборке. Остаются 2 категории дохода: от 200к до 1кк(B) и 50к до 200к(С). Если сравнивать их, то можно сказать: люди с более высоким доходом более склонны возвращать кредит в срок на 19,7%** 

# <div class="alert alert-block alert-success">
# <b>Комментарий ревьюера:</b>
# 
# ✔️ Молодец, что обратил внимание на сбалансированность выборок)) 
#   </div>

# #### 3.4 Как разные цели кредита влияют на его возврат в срок?

# In[31]:


data_pivot_purpose = data.pivot_table(index=['purpose_category'], values = 'debt', aggfunc=['sum', 'count', 'mean'])
data_pivot_purpose.columns = ['debt', 'all', 'mean']
data_pivot_purpose['mean'] = data_pivot_purpose['mean'].round(3) * 100
data_pivot_purpose = data_pivot_purpose.sort_values(by= 'mean').reset_index()
display(data_pivot_purpose)


# In[32]:


plt.title('Зависимость между целью и возвратом кредита')
sns.barplot(x='mean', y='purpose_category', data=data_pivot_purpose)
plt.show()


# **Самые надёжные цели для кредитования - это операции с недвижимостью, вероятнее всего по той причине, что при операциях с жильём банк оформляет её под залог. В сравнении с ипотекой, операции с автомобилем и получение образования менее надежны на 27,4%** 

# <div class="alert alert-block alert-warning">
# <b>КОММЕНТАРИЙ РЕВЬЮВЕРА:</b> 
#     
#     
# ⚠️ Почему ты думаешь, что самые надежные клиенты, те кто берет ипотеку?)) 
# 
# </div>

# <div class="alert alert-block alert-success">
# <b>Комментарий ревьюера_V2:</b>
# 
# ✔️ Плюс самые жесткую требования предъявляются к людям, кто берет ипотеку))
#   </div>

# #### 3.5 Приведите возможные причины появления пропусков в исходных данных.

# *В данной работе я столкнулся с пропусками в нескольких категориях:
# Доход - Скорее всего, не все желают его указывать
# Трудовой стаж - здесь, скорее, проблема в несовершенстве систем контроля трудового стажа.
# При проверке  данных в столбце "количество детей" присутствовало два аномальных значения. Это - человеческий фактор.* 

# <div class="alert alert-block alert-success">
# <b>Комментарий ревьюера:</b>
# 
# ✔️ Ответ, правильный)) 
#   </div>

# #### 3.6 Объясните, почему заполнить пропуски медианным значением — лучшее решение для количественных переменных.

# Среднее значение некорректно характеризует данные, когда некоторые значения сильно выделяются среди большинства. В данной работе существуют показатели, которые при подсчёте среднего значения сильно исказит информацию(к примеру доход). Так что при такой выборке самым оптимальным решением выглядит заполнение пропусков медианным значением.

# <div class="alert alert-block alert-warning">
# <b>КОММЕНТАРИЙ РЕВЬЮВЕРА:</b> 
#     
#     
# ⚠️ А в чем проблема среднего значения?)) 
# 
# </div>

# <div class="alert alert-block alert-success">
# <b>Комментарий ревьюера_V2:</b>
# 
# ✔️ Все верно, среднее значение очень зависит от выбросов))
#   </div>

# ### Шаг 4: общий вывод.

# Идеальный клиент банка это человек, находящийся в официальном браке, не имеющий детей с доходом от 200к и взявший кредит на операции с недвижимостью. Возможно, на основании этого исследования, стоит присуждать кредитозаёмщикам категории не только учитывая их доход, но и наличие детей, официальные отношения и цель кредита. Так же я бы посоветовал обратить внимание банка на многодетные семьи и предложить им привлекательные условия. Не смотря на малое количество таких кредитозаёмщиков, они показывают хорошую статистику по возвратам. Такая компания могла бы иметь пользу как минимум для сбора данных.
# 

# <div class="alert alert-block alert-success">
# <b>Комментарий ревьюера:</b>
# 
# ✔️ Молодец, отличные выводы написал, даны рекомендации в работе это правильно)) 
#   </div>

# <div class="alert alert-block alert-success">
# <b>Комментарий ревьюера:</b>
# 
# ✔️ Максим, отличная работа, хорошо владеешь кодом, начал уже визуализировать графики, подправь некоторые недостатки и можно двигаться дальше)) Успехов в обучении)) 
#   </div>

# <div class="alert alert-block alert-success">
# <b>Комментарий ревьюера:</b>
# 
# ✔️ Максим, давай оптимизируем код в шаге изучение взаимосвязей и можно двигаться дальше, а так отличная работа)) 
#   </div>

# <div class="alert alert-block alert-info">
# <b> Исправил работу кода на всех этапах, единственное, что если можно засчитать решение без droplevel, а просто с переименованием столбцов, было бы не плохо. Я разобрался как он работает и объяснения вполне доходчивые, просто побоялся опять запутаться в индексах.
# Последний вопрос: а можно ли было как нибудь оптимизировать эту запись (data_pivot_purpose['mean'] =data_pivot_purpose['mean'].round(3) * 100) на этапе созданиря сводной таблицы? То есть применить к столбцу не только метод mean, но и произвести какие-то подсчёты?
#     </b>

# <div class="alert alert-block alert-success">
# <b>Комментарий ревьюера_V3:</b>
# 
# ✔️ Максим, все отлично, хорошо поработал, тебе и не нужен бы droplevel, ты заменял название столбцов, так тоже вполне годится)) По твоему вопросу к сожалению только вот таким способом можно сделать, хотя вроде если использовать lambda https://pythonru.com/osnovy/vse-chto-nuzhno-znat-o-lambda-funkcijah-v-python, то можно попробывать,  но вот сейчас я не могу подсказать как это сделать в данном случае)) 
#   </div>
